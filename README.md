# Vine_Repro
* まず、バイナリからLLVMを作る。
  * REV.NG はバイナリをLLVMにリフトアップしてくれる。
    * [REV.NG ツール](https://rev.ng/revng-features.html)
    * [REV.NG 論文](https://dl.acm.org/doi/10.1145/3033019.3033028)

* LLVM から CFGを作る。

* CFG から 実行パスをとる。
  * 実行パスは 

* パスに沿って

* 以下論文より抜粋
~~~
Vineは4つの要素で構成されています。

トレースコレクタ、リフティングコンポーネント、解析コンポーネント、決定手続きインタフェースコンポーネントの4つの要素です。

　我々は、システム全体のエミュレータであるQEMU [55]の上にトレースコレクタを実装しました。

キーボードやネットワーク入力などの指定された外部入力がどのようにオペレーティングシステムに流入するかを追跡するために、QEMUを修正しました。

オペランドが外部入力から派生した命令には、特別な "taint "フラグが割り当てられており、これは、それらが潜在的なエクスプロイトの入力であることを、残りのシステムに示しています。

出力ログには、実行された各命令のアドレスと各命令のオペランド値が含まれています。

　リフティング・コンポーネントは、ネイティブバイナリを読み込み、バイナリフォーマットを解析し、コードセグメントを逆アセンブルし、図２に示す言語に基づいた中間表現（IR）にアセンブリをリフティングします。

我々は、2つの逆アセンブラとのインタフェースを接続しています : 
IDA-Proという市販の逆アセンブラと、[56]に記載されている逆アセンブラです。

　Vine言語の利点は、x86 命令セットを解析しやすくすることです。

例えば、x86には単一の命令ループ（例： rep接頭辞）と暗黙の副作用（多くの命令は暗黙のうちにeflagsレジスタを更新またはテストします）があります。同じレジスタは複数の方法でアドレス指定可能であったり（例：alレジスタはeaxの下位8ビットをアドレス指定します）、オペランドごとに異なる動作をすることがあります（例：0でシフトしてもeflagsは設定されませんが、他の値は設定されます）。

これらの動作はすべて、より管理しやすいステートメントのセットに変換されています。

我々の実装では、浮動小数点演算を除いて、ほとんどすべての86命令を処理しています。

リフティングコンポーネントには約16,500行のC/C++コードが含まれています。

解析コンポーネントは、4節で説明した後続の解析、型チェック、制御フローとコールグラフの構築、データフロー解析、その他の最適化、そしてCコードを生成する我々の言語用のコンパイラを担当しています。

このCコードは、任意のCコンパイラでコンパイルすることができます。

　解析コンポーネントはOCamlで書かれ、約28,000行のコードです。

最後のコンポーネントは、OCamlルーチンと決定手順とのインターフェースです。

現在、我々はSTP [25]、[26]、[57]、CVCL [58]とインタフェースしていますが、これらはどちらも満足度指向(SAT)の決定手続きです。

~~~
